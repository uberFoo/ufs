//! IOFS Messages sent to WASM programs
//!
//! These are file system events that are generated by the file system.
//!
use {
    crate::{
        server::{IofsGetValue, IofsPostValue},
        uuid::UfsUuid,
        wasm::RuntimeErrorKind,
    },
    failure,
    log::error,
    serde_derive::Serialize,
    serde_json,
    std::{convert::TryInto, path::PathBuf, str},
    uuid::Uuid,
    wasm_exports::MessagePayload,
    wasmer_runtime::{Instance, Value},
};

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub(crate) enum IofsMessage {
    SystemMessage(IofsSystemMessage),
    FileMessage(IofsFileMessage),
    DirMessage(IofsDirMessage),
}

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub(crate) enum IofsSystemMessage {
    Shutdown,
    Ping,
}

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub(crate) enum IofsFileMessage {
    Create(IofsMessagePayload),
    Delete(IofsMessagePayload),
    Open(IofsMessagePayload),
    Close(IofsMessagePayload),
    Write(IofsMessagePayload),
    Read(IofsMessagePayload),
}

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub(crate) enum IofsDirMessage {
    Create(IofsMessagePayload),
    Delete(IofsMessagePayload),
}

#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize)]
pub(crate) struct IofsMessagePayload {
    pub(crate) target_id: UfsUuid,
    pub(crate) target_path: PathBuf,
    pub(crate) parent_id: UfsUuid,
}

impl From<&IofsMessagePayload> for MessagePayload {
    fn from(imp: &IofsMessagePayload) -> Self {
        MessagePayload {
            id: imp.target_id.into(),
            path: imp.target_path.clone(),
            parent_id: imp.parent_id.into(),
        }
    }
}

pub(crate) struct WasmMessageSender<'a> {
    instance: &'a mut Instance,
}

impl<'a> WasmMessageSender<'a> {
    pub(crate) fn new(instance: &'a mut Instance, root_id: UfsUuid) -> Self {
        let mut wms = WasmMessageSender { instance };

        let root_id: Uuid = root_id.into();
        let id_str = serde_json::to_string(&root_id).expect("unable to serialize JSON in new");
        wms.write_wasm_memory(0, &id_str);

        wms.call_wasm_func(
            "__init",
            Some(&[Value::I32(0), Value::I32(id_str.len() as _)]),
        )
        .expect("error calling init function");
        wms
    }

    fn call_wasm_func(
        &mut self,
        name: &str,
        args: Option<&[Value]>,
    ) -> Result<Vec<Value>, failure::Error> {
        let args = match args {
            Some(a) => a,
            None => &[],
        };

        match self.instance.call(name, args) {
            Ok(v) => Ok(v),
            Err(e) => {
                error!("Error invoking wasm function {}", e);
                Err(RuntimeErrorKind::FunctionInvocation.into())
            }
        }
    }

    fn write_wasm_memory(&mut self, offset: usize, s: &str) {
        let memory = self.instance.context_mut().memory(0);

        for (byte, cell) in s
            .bytes()
            .zip(memory.view()[offset..(offset + s.len()) as usize].iter())
        {
            cell.set(byte);
        }
    }

    fn unbox_wasm_string(&self, str_ptr: usize) -> String {
        let memory = self.instance.context().memory(0);
        let len_vec: Vec<u8> = memory.view()[1..5].iter().map(|cell| cell.get()).collect();
        let len = u32::from_le_bytes(len_vec.as_slice().try_into().unwrap());
        let bytes: Vec<u8> = memory.view()[str_ptr..str_ptr + len as usize]
            .iter()
            .map(|cell| cell.get())
            .collect();

        String::from_utf8_lossy(&bytes).to_string()
    }

    pub(crate) fn send_shutdown(&mut self) -> Result<(), failure::Error> {
        self.call_wasm_func("__handle_shutdown", None)?;
        Ok(())
    }

    pub(crate) fn send_ping(&mut self) -> Result<(), failure::Error> {
        self.call_wasm_func("__handle_ping", None)?;
        Ok(())
    }

    pub(crate) fn send_file_create(
        &mut self,
        payload: &IofsMessagePayload,
    ) -> Result<(), failure::Error> {
        let payload: MessagePayload = payload.into();

        let json_str =
            serde_json::to_string(&payload).expect("unable to serialize JSON in send_file_create");

        self.write_wasm_memory(0, &json_str);

        self.call_wasm_func(
            "__handle_file_create",
            Some(&[Value::I32(0), Value::I32(json_str.len() as i32)]),
        )?;
        Ok(())
    }

    pub(crate) fn send_dir_create(
        &mut self,
        payload: &IofsMessagePayload,
    ) -> Result<(), failure::Error> {
        let payload: MessagePayload = payload.into();
        let json_str =
            serde_json::to_string(&payload).expect("unable to serialize JSON in send_dir_create");

        self.write_wasm_memory(0, &json_str);

        self.call_wasm_func(
            "__handle_dir_create",
            Some(&[Value::I32(0), Value::I32(json_str.len() as i32)]),
        )?;
        Ok(())
    }

    pub(crate) fn send_file_delete(
        &mut self,
        payload: &IofsMessagePayload,
    ) -> Result<(), failure::Error> {
        let payload: MessagePayload = payload.into();
        let json_str =
            serde_json::to_string(&payload).expect("unable to serialize JSON in send_file_delete");

        self.write_wasm_memory(0, &json_str);

        self.call_wasm_func(
            "__handle_file_delete",
            Some(&[Value::I32(0), Value::I32(json_str.len() as i32)]),
        )?;
        Ok(())
    }

    pub(crate) fn send_dir_delete(
        &mut self,
        payload: &IofsMessagePayload,
    ) -> Result<(), failure::Error> {
        let payload: MessagePayload = payload.into();
        let json_str =
            serde_json::to_string(&payload).expect("unable to serialize JSON in send_dir_delete");

        self.write_wasm_memory(0, &json_str);

        self.call_wasm_func(
            "__handle_dir_delete",
            Some(&[Value::I32(0), Value::I32(json_str.len() as i32)]),
        )?;
        Ok(())
    }

    pub(crate) fn send_file_open(
        &mut self,
        payload: &IofsMessagePayload,
    ) -> Result<(), failure::Error> {
        let payload: MessagePayload = payload.into();
        let json_str =
            serde_json::to_string(&payload).expect("unable to serialize JSON in send_file_open");

        self.write_wasm_memory(0, &json_str);

        self.call_wasm_func(
            "__handle_file_open",
            Some(&[Value::I32(0), Value::I32(json_str.len() as i32)]),
        )?;
        Ok(())
    }

    pub(crate) fn send_file_close(
        &mut self,
        payload: &IofsMessagePayload,
    ) -> Result<(), failure::Error> {
        let payload: MessagePayload = payload.into();
        let json_str = serde_json::to_string(&payload)
            .expect("unable to serialize JSON in send_http_post send_file_close");

        self.write_wasm_memory(0, &json_str);

        self.call_wasm_func(
            "__handle_file_close",
            Some(&[Value::I32(0), Value::I32(json_str.len() as i32)]),
        )?;
        Ok(())
    }

    pub(crate) fn send_file_write(
        &mut self,
        payload: &IofsMessagePayload,
    ) -> Result<(), failure::Error> {
        let payload: MessagePayload = payload.into();
        let json_str =
            serde_json::to_string(&payload).expect("unable to serialize JSON in send_file_write");

        self.write_wasm_memory(0, &json_str);

        self.call_wasm_func(
            "__handle_file_write",
            Some(&[Value::I32(0), Value::I32(json_str.len() as i32)]),
        )?;
        Ok(())
    }

    pub(crate) fn send_file_read(
        &mut self,
        payload: &IofsMessagePayload,
    ) -> Result<(), failure::Error> {
        let payload: MessagePayload = payload.into();
        let json_str =
            serde_json::to_string(&payload).expect("unable to serialize JSON in send_file_read");

        self.write_wasm_memory(0, &json_str);

        self.call_wasm_func(
            "__handle_file_read",
            Some(&[Value::I32(0), Value::I32(json_str.len() as i32)]),
        )?;
        Ok(())
    }

    pub(crate) fn send_http_get(&mut self, msg: &IofsGetValue) -> Result<String, failure::Error> {
        self.write_wasm_memory(5, &msg.route());
        match self.call_wasm_func(
            "__handle_http_get",
            Some(&[Value::I32(5), Value::I32(msg.route().len() as i32)]),
        ) {
            Ok(value) => {
                if let Value::I32(v) = value[0] {
                    Ok(self.unbox_wasm_string(v as usize))
                } else {
                    Err(RuntimeErrorKind::IofsInvocation.into())
                }
            }
            Err(e) => Err(e),
        }
    }

    pub(crate) fn send_http_post(&mut self, msg: &IofsPostValue) -> Result<String, failure::Error> {
        let json_str =
            serde_json::to_string(msg.json()).expect("unable to serialize JSON in send_http_post");
        self.write_wasm_memory(5, &msg.route());
        self.write_wasm_memory(5 + msg.route().len(), &json_str);
        match self.call_wasm_func(
            "__handle_http_post",
            Some(&[
                Value::I32(5),
                Value::I32(msg.route().len() as i32),
                Value::I32(5 + msg.route().len() as i32),
                Value::I32(json_str.len() as i32),
            ]),
        ) {
            Ok(value) => {
                if let Value::I32(v) = value[0] {
                    Ok(self.unbox_wasm_string(v as usize))
                } else {
                    Err(RuntimeErrorKind::IofsInvocation.into())
                }
            }
            Err(e) => Err(e),
        }
    }
}
